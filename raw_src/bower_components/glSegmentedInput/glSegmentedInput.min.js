/*! 
  glSegmentedInput v(0.0.11) 
  (c) 2013-2015
  https://gluenetworks.kilnhg.com/Code/Web-Development
  Release Date: 2015-03-26 
*/

angular.module("glSegmentedInput", [ "glTextfield" ]), angular.module("glSegmentedInput").directive("glSegmentedInput", [ "$compile", "$q", "$timeout", function(a, b, c) {
    "use strict";
    return {
        restrict: "E",
        scope: {
            settings: "=",
            api: "="
        },
        link: function(d, e) {
            function f(a) {
                return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            }
            function g(a, b) {
                var c = b.settings.idx;
                if (!angular.isUndefined(a)) {
                    if (!angular.isUndefined(d.api._data.parseSegmentRegex) && d.api._data.parseSegmentRegex.test(a)) // handle paste actions containing full segmented string
                    return void d.api.setValue(a);
                    if (angular.isFunction(d.api._data.segments[c].processValue)) {
                        var e = d.api._data.segments[c].processValue(a);
                        if (e != a) return void d.segApis[c].setValue(e);
                    } else if (angular.isFunction(d.api._data.processValue)) {
                        var e = d.api._data.processValue(a);
                        if (e != a) return void d.segApis[c].setValue(e);
                    }
                }
                d.api._data.segmentValues[c] = a;
            }
            function h(a, b) {
                var c = b.settings.idx;
                if (9 == a.keyCode) return void k(c);
                var e = String.fromCharCode(a.keyCode);
                if (!a.metaKey && !a.ctrlKey) // focus to prev/next segment keys
                if (angular.isArray(d.api._data.tabFocusKeyCodes) && -1 != d.api._data.tabFocusKeyCodes.indexOf(a.keyCode)) {
                    if (a.preventDefault(), a.shiftKey && c > 0) t[c - 1].find("input").focus(), k(c); else if (!a.shiftKey && c < d.api._data.segments.length) {
                        var f = t[c + 1].find("input");
                        f.focus(), k(c);
                    }
                } else l(a) && (angular.isUndefined(d.api._data.segments[c].validKeyRegex) ? angular.isUndefined(d.api._data.validKeyRegex) || 0 == d.api._data.validKeyRegex.test(e) && a.preventDefault() : 0 == d.api._data.segments[c].validKeyRegex.test(e) && a.preventDefault());
            }
            function i(a, b) {
                var c = b.settings.idx, e = t[c].find("input"), f = j(e[0]).start, g = d.api._data.segmentValues[c], h = angular.isUndefined(g) ? 0 : g.length;
                39 == a.keyCode && c < t.length - 1 && f == h && f == J ? (// ARROW KEY RIGHT focus next field
                t[c + 1].find("input").focus(), J = 0) : 37 == a.keyCode && c > 0 && 0 == f && f == J ? (// ARROW KEY LEFT focus prev field
                t[c - 1].find("input").focus(), J = 0) : J = f;
            }
            function j(a) {
                var b = a.ownerDocument, c = {
                    start: 0,
                    end: 0,
                    caret: 0
                };
                if (-1 != navigator.appVersion.indexOf("MSIE")) if ("TEXTAREA" == a.tagName) {
                    a.value.charCodeAt(a.value.length - 1) < 14 && (a.value = a.value.replace(/34/g, "") + String.fromCharCode(28));
                    var d = b.selection.createRange(), e = d.duplicate();
                    e.moveToElementText(a), e.setEndPoint("StartToEnd", d), c.end = a.value.length - e.text.length, 
                    e.setEndPoint("StartToStart", d), c.start = a.value.length - e.text.length, c.caret = c.end, 
                    a.value.substr(a.value.length - 1) == String.fromCharCode(28) && (a.value = a.value.substr(0, a.value.length - 1));
                } else {
                    var d = b.selection.createRange(), e = d.duplicate();
                    c.start = 0 - e.moveStart("character", -1e5), c.end = c.start + d.text.length, c.caret = c.end;
                } else c.start = a.selectionStart, c.end = a.selectionEnd, c.caret = c.end;
                return c.start < 0 && (c = {
                    start: 0,
                    end: 0,
                    caret: 0
                }), c;
            }
            function k(a) {
                c(function() {
                    var b = d.segApis[a].getValue();
                    angular.isUndefined(d.api._data.defaultEmptyValue) || (angular.isUndefined(b) || null == b || "" == b) && (angular.isUndefined(d.api._data.segments[a].defaultEmptyValue) ? angular.isUndefined(d.api._data.defaultEmptyValue) || d.segApis[a].setValue(d.api._data.defaultEmptyValue) : d.segApis[a].setValue(d.api._data.segments[a].defaultEmptyValue));
                }, 100);
            }
            function l(a) {
                var b = a.keyCode, c = b > 47 && 58 > b || // number keys
                32 == b || // spacebar
                // keycode == 13   || // return key
                b > 64 && 91 > b || // letter keys
                b > 95 && 112 > b || // numpad keys
                b > 185 && 193 > b || // ;=,-./` (in order)
                b > 218 && 223 > b;
                // [\]' (in order)
                return c;
            }
            var m, n, o, p, q, r, s = d.$new(), t = [];
            if (d.api = d.api || {}, d.api._data = {}, m = d.api._data.name = angular.isUndefined(d.settings.name) ? void 0 : d.settings.name, 
            d.api._data.segments = angular.isUndefined(d.settings.segments) ? void 0 : d.settings.segments, 
            d.api._data.parseSegmentRegex = angular.isUndefined(d.settings.parseSegmentRegex) ? void 0 : d.settings.parseSegmentRegex, 
            d.api._data.segmentValues = angular.isUndefined(d.settings.value) ? [] : d.settings.value.split(d.api._data.parseSegmentRegex), 
            d.api._data.value = angular.isUndefined(d.settings.value) ? void 0 : d.settings.value, 
            d.api._data.delimiter = angular.isUndefined(d.settings.delimiter) ? void 0 : d.settings.delimiter, 
            d.api._data.placeholder = angular.isUndefined(d.settings.placeholder) ? void 0 : d.settings.placeholder, 
            d.api._data.defaultEmptyValue = angular.isUndefined(d.settings.defaultEmptyValue) ? void 0 : d.settings.defaultEmptyValue, 
            d.api._data.validKeyRegex = angular.isUndefined(d.settings.validKeyRegex) ? void 0 : d.settings.validKeyRegex, 
            d.api._data.tabFocusKeyCodes = angular.isUndefined(d.settings.tabFocusKeyCodes) ? void 0 : d.settings.tabFocusKeyCodes, 
            d.api._data.valid = angular.isUndefined(d.settings.valid) ? !0 : d.settings.valid, 
            d.api._data.label = angular.isUndefined(d.settings.label) ? void 0 : d.settings.label, 
            d.api._data.disabled = angular.isUndefined(d.settings.disabled) ? !1 : d.settings.disabled, 
            d.api._data.error = angular.isUndefined(d.settings.error) ? void 0 : d.settings.error, 
            d.api._data.editable = angular.isUndefined(d.settings.editable) ? !0 : d.settings.editable, 
            d.api._data.onChange = angular.isFunction(d.settings.onChange) ? d.settings.onChange : void 0, 
            d.api._data.processValue = angular.isFunction(d.settings.processValue) ? d.settings.processValue : void 0, 
            angular.isString(d.api._data.delimiter)) for (var u = 0; u < d.api._data.segments.length; u++) {
                var v = d.api._data.segments[u];
                u < d.api._data.segments.length - 1 && angular.isUndefined(v.after) && angular.isUndefined(d.api._data.segments[u + 1].before) && (d.api._data.segments[u].after = d.api._data.delimiter);
            }
            // DYNAMICALLY BUILD UP REGEX...
            if (angular.isUndefined(d.api._data.parseSegmentRegex)) {
                for (var w = [], x = "", y = 0; y < d.api._data.segments.length; y++) {
                    {
                        d.api._data.segments[y];
                    }
                    angular.isString(d.api._data.segments[y].before) && -1 == w.indexOf(d.api._data.segments[y].before) && w.push(d.api._data.segments[y].before), 
                    angular.isString(d.api._data.segments[y].after) && -1 == w.indexOf(d.api._data.segments[y].after) && w.push(d.api._data.segments[y].after);
                }
                for (var z = 0; z < w.length; z++) {
                    var A = w[z];
                    A = f(A), x += z > 0 ? "|" + A : A;
                }
                x.length && (d.api._data.parseSegmentRegex = new RegExp(x));
            }
            var B = [];
            d.segApis = [], d.segSettings = [];
            for (var C = 0; C < d.api._data.segments.length; C++) {
                var D = d.api._data.segments[C];
                d.segSettings[C] = {
                    idx: C,
                    name: angular.isUndefined(d.api._data.segments[C].name) ? m + "-" + C : d.api._data.segments[C].name,
                    onChange: g,
                    onKeyDown: h,
                    onKeyUp: i,
                    placeholder: angular.isUndefined(d.api._data.segments[C].placeholder) ? d.api._data.placeholder : d.api._data.segments[C].placeholder
                };
                var E = "";
                angular.isString(D.before) && (E += '<span class="gl-segment-delimiter gl-segment-delimiter-before delimiter-seg-' + C + '" >' + D.before + "</span>"), 
                E += '<gl-textfield class="' + d.api._data.name + " input-seg-" + C + '" api="segApis[' + C + ']" settings="segSettings[' + C + ']" ></gl-textfield>', 
                angular.isString(D.after) && (E += '<span class="gl-segment-delimiter gl-segment-delimiter-after delimiter-seg-' + C + '" >' + D.after + "</span>"), 
                B[C] = E;
            }
            var F = '<div class="gl-segmented-input-fields"></div>', G = '<p class="gl-error-msg">{{api._data.error}}</p>', H = '<label class="gl-view-label">{{api._data.label}}</label>', I = '<p class="gl-view-value"></p>';
            d.api.setLabel = function(a) {
                d.api._data.label = a;
            }, d.api.getLabel = function() {
                return d.api._data.label;
            }, d.api.view = function() {
                M();
            }, d.api.edit = function() {
                N();
            }, d.api.disable = function() {
                d.api._data.disabled = !0;
                for (var a = 0; a < d.segApis.length; a++) {
                    var b = d.segApis[a];
                    b.disable();
                }
            }, d.api.enable = function() {
                d.api._data.disabled = !1;
                for (var a = 0; a < d.segApis.length; a++) {
                    var b = d.segApis[a];
                    b.enable();
                }
            };
            // KEY UP
            var J = 0;
            d.api.setInvalid = function(a) {
                d.api._data.valid = !1, d.api._data.error = angular.isString(a) ? a : void 0;
                for (var b = 0; b < d.api._data.segments.length; b++) d.segApis[b].setInvalid();
                K();
            }, d.api.setValid = function() {
                d.api._data.valid = !0;
                for (var a = 0; a < d.segApis.length; a++) {
                    var b = d.segApis[a];
                    b.setValid();
                }
                K();
            };
            var K = function() {
                angular.isUndefined(p) || p.remove(), d.api._data.editable && !d.api._data.valid && angular.isString(d.api._data.error) && (p = a(angular.element(G))(d), 
                e.append(p));
            };
            d.api.getValue = function() {
                return d.api._data.value;
            }, d.api.setValue = function(a) {
                n = b.defer(), d.api._data.segmentValues = a.split(d.api._data.parseSegmentRegex);
                for (var c = 0; c < d.api._data.segmentValues.length; c++) {
                    var e = d.api._data.segmentValues[c];
                    angular.isFunction(d.api._data.segments[c].processValue) ? e = d.api._data.segments[c].processValue(e) : angular.isFunction(d.api._data.processValue) && (e = d.api._data.processValue(e)), 
                    angular.isUndefined(d.segApis[c]) || d.segApis[c].setValue(e), d.api._data.segmentValues[c] = e;
                }
                return n.promise;
            };
            var L = function() {
                s.$destroy(), e.children().remove(), s = d.$new(), o = angular.element(F);
                for (var b = 0; b < B.length; b++) {
                    var c = B[b], f = angular.element(c);
                    t[b] = f, o.append(t[b]);
                }
                var g = a(o)(s);
                e.append(g);
            }, M = function() {
                d.api._data.editable = !1, e.children().remove(), angular.isString(d.api._data.label) && (q = a(angular.element(H))(d), 
                e.append(q)), r = a(angular.element(I))(d), r.html(d.api.getValue()), e.append(r);
            }, N = function() {
                d.api._data.editable = !0, L();
                var a = d.api._data.value;
                K(), // move to the back of the line so setValue has been applied to the api before setting value
                c(function() {
                    if (angular.isString(a) && "" != a && d.api.setValue(a), d.api._data.valid) d.api.setValid(); else {
                        var b = angular.isString(d.api._data.error) ? d.api._data.error : void 0;
                        d.api.setInvalid(b);
                    }
                    d.api._data.disabled && d.api.disable();
                }, 0);
            };
            // INIT
            d.$watchCollection("api._data.segmentValues", function() {
                for (var a = "", b = 0; b < d.api._data.segmentValues.length; b++) {
                    var c = d.api._data.segmentValues[b];
                    angular.isString(d.api._data.segments[b].before) && (a += d.api._data.segments[b].before), 
                    a += angular.isUndefined(c) ? "" : c, angular.isString(d.api._data.segments[b].after) && (a += d.api._data.segments[b].after);
                }
                d.api._data.value = a;
            }), d.$watch("api._data.value", function(a, b) {
                angular.isUndefined(n) || n.resolve(a), // update view  mode
                angular.isUndefined(r) || r.html(a), angular.isFunction(d.api._data.onChange) && d.api._data.onChange(a, b);
            }), angular.isUndefined(d.settings.view) || 1 != d.settings.view ? N() : M();
        }
    };
} ]);
//# sourceMappingURL=glsegmentedinput.min.js.map